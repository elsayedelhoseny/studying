## مقدمة عن المقابلة الوهمية المباشرة
- تهدف المقابلة المباشرة إلى مساعدة المطورين على فهم أسئلة المقابلات وإجاباتها، وكيفية سير العملية.   
- الغرض الأساسي تعليمي، ليس مقابلة حرفية، ويهدف لتوضيح ما ينقص المطورين وما يحتاجون لمراجعته.    
- يعبر هذا المحتوى عن منهجية عبد العظيم الخاصة في المقابلات، والتي قد تختلف من شركة لأخرى.   
- يمكن للمشاركين تصحيح أي معلومات خاطئة تُذكر خلال المقابلة.   

## مبادئ البرمجة الشيئية (OOP)
  
    

## مبادئ SOLID
- **مبدأ المسؤولية الواحدة (Single Responsibility Principle - SRP):** يجب أن يكون للكلاس مسؤولية واحدة فقط، وسبب واحد للتغيير فيه، مما يسهل التعديل.   
- **مبدأ استبدال ليسكوف (Liskov Substitution Principle - LSP):** يجب أن تكون الكلاسات الفرعية (Subclasses) قابلة للاستبدال بالكلاس الأساسي (Parent Class) دون تغيير في صحة البرنامج.   
    - للتحقق من تطبيقه: إذا كان هناك دالة في الواجهة (Interface) موجودة في كلاس فرعي واحد فقط، فهذا يخالف المبدأ.    
- **مبدأ عكس التبعية (Dependency Inversion Principle - DIP):** يجب أن تعتمد الوحدات ذات المستوى الأعلى (High-level modules) والوحدات ذات المستوى الأدنى (Low-level modules) على التجريدات (Abstractions)، لا على التفاصيل الملموسة.   
    - مثال: عدم اعتماد الـ Repository مباشرة على Data Source، بل على Interface بينهما لتجنب المشاكل عند إضافة Data Sources جديدة أو تعديلها.    
    - فائدته: يقلل من تأثير التغييرات، ويساعد على تطبيق مبدأ الفتح/الإغلاق (OCP).   
- **حقن التبعية (Dependency Injection - DI):** طريقة لتوفير كائنات (Objects) للكلاسات التي تحتاجها من الخارج (عبر Constructor أو Setter) بدلاً من إنشاء الكائن داخل الكلاس نفسه.   
    - يرتبط بمفهوم **Inversion of Control (IoC)**، حيث يقوم إطار العمل (مثل GetIt في Flutter) بإنشاء الكائنات وإدارتها.    

## أنماط التصميم (Design Patterns)
- هي حلول مجربة لمشاكل برمجية متكررة، توفر وصفًا للمشكلة والحل معًا.    
- ليست إجبارية؛ يجب استخدامها فقط عند مواجهة المشكلة التي صُممت لحلها، وعدم فرضها على الكود.    
- تنقسم إلى أنماط عامة (General) وأنماط خاصة بإطار عمل معين (Framework-specific) مثل Bloc في Flutter.   

### نمط Singleton
- يسمح بوجود نسخة واحدة فقط (Instance) من كلاس معين في الذاكرة، مع نقطة وصول عالمية إليها.   
- **الهدف:** توفير موارد الذاكرة، وضمان تناسق البيانات (Data Consistency) في حالات مثل الاتصال بقاعدة البيانات.    
- **التطبيق:** يتم إنشاء الكائن عند الحاجة (Lazy Instantiation) عن طريق التحقق مما إذا كان الكائن موجودًا بالفعل، وإذا لم يكن يتم إنشاؤه.   
- **عيوبه:** قد يسبب مشاكل في الاختبار (Testing) لأنه يصعب استبدال الكائن الوحيد بنسخة وهمية (Mock).    

### نمط Observer
- يسمح للكائنات (Observers) بالاشتراك في تلقي الإشعارات من كائن آخر (Subject) عند حدوث تغيير معين.   
- **مثال في Flutter:** الـ Streams في Dart، وBloc في إدارة الحالة، حيث يقوم الـ View بعمل `listen` على الـ Bloc لتحديث واجهة المستخدم عند تغيير الحالة.    

## هياكل البيانات والخوارزميات
- **الفرق بين Stack و Queue:**
    - **Stack (المكدس):** يستخدم مبدأ **LIFO (Last In, First Out)**، أي آخر عنصر يدخل هو أول من يخرج. يشبه هدم برج من الأعلى.   
    - **Queue (الطابور):** يستخدم مبدأ **FIFO (First In, First Out)**، أي أول عنصر يدخل هو أول من يخرج. يشبه طابور المصلحة الحكومية.    
- **التعقيد الزمني (Big O Notation):**
    - يصف كفاءة الخوارزمية. مثال: حلقة متداخلة (Nested Loop) يكون تعقيدها $$O(n^2)$$.    
    - عند وجود عمليات متسلسلة، يتم أخذ التعقيد الأكبر فقط (مثل $$O(n^2) + O(n)$$ يصبح $$O(n^2)$$).   
- **Merge Sort:** خوارزمية فرز تعتمد على مبدأ Divide and Conquer (قسّم تسُد)، حيث يتم تقسيم القائمة إلى نصفين بشكل متكرر ثم دمجها.    

## أساسيات Flutter
- **StatelessWidget vs. StatefulWidget:**
    - **StatelessWidget:** لا تتغير حالته بعد بنائه، ويستخدم للواجهات الثابتة. يحتوي على `build` method فقط.   
    - **StatefulWidget:** تتغير حالته أثناء دورة حياة الودجت، ويستخدم للواجهات الديناميكية. يحتوي على `createState` و `build` بالإضافة إلى `initState` و `dispose` وغيرها.    
- **BuildContext:**
    - هو مرجع لموقع الودجت في شجرة الودجت (Widget Tree).   
    - يستخدم للوصول إلى الثيم (Theme)، الـ Media Query، أو مقدمي الحالة (State Providers) مثل BlocProvider.    
    - يصف حالة الودجت وموقعه في التطبيق، وما يحيط به من ودجتات.   
    - يمكن من خلاله الوصول إلى الودجتات أو الكائنات الموجودة في الشجرة أعلى الودجت الحالي.    

## إدارة الحالة (State Management) في Flutter
- تتطلب المرونة والقدرة على تعلم أنماط جديدة، حيث تختلف طرق إدارة الحالة بين الشركات.   
- **Bloc vs. Cubit (أو Provider):**
    - **Cubit (أو Provider):** مناسب للمشاريع الصغيرة أو الميزات البسيطة، حيث يكون تدفق الحالة مباشرًا.    
    - **Bloc:** يفضل للمشاريع الكبيرة والمعقدة التي تحتوي على العديد من الحالات (States) والأحداث (Events)، ويوفر تنظيمًا أفضل واختبارية أعلى.    
    - **متى يتم استخدام Bloc بدلاً من Cubit؟** عندما تحتاج إلى التحكم في تدفق الأحداث (Events) من المستخدم، مثل البحث (Search) حيث يمكن معالجة ضغطات المفاتيح المتعددة (Debouncing) وتأخير إرسال الطلبات لتحسين الأداء.     
    - **يمكن دمج Cubit مع Bloc:** استخدام Cubit للميزات البسيطة، والتحول إلى Bloc عند الحاجة إلى معالجة الأحداث المعقدة.    

## تقليل إعادة بناء الودجت (Widget Rebuilds)
- **تحديد نطاق البناء:** استخدام مقدمي الحالة (State Providers) مثل BlocProvider في الأماكن التي تحتاج إلى تحديث فقط، وليس في جذر التطبيق (Root).   
- **استخدام `const`:** استخدام الكلمة المفتاحية `const` للودجتات التي لا تتغير، مما يمنع إعادة بنائها.    
- **استخدام `Keys`:** مفيدة في ترتيب القوائم (Lists) وتحديد الودجتات بشكل فريد.   
- **Lazy Indexed Stack:** يسمح بإنشاء الودجتات فقط عند الحاجة إليها (Lazy Loading) والحفاظ على حالتها عند العودة إليها، مما يوفر موارد الذاكرة والمعالجة.     

## ودجتات ومفاهيم Flutter
- **SizedBox vs. Container:**
    - **SizedBox:** يستخدم لإنشاء مساحة فارغة أو تحديد أبعاد ثابتة، وهو أخف وأكثر كفاءة.    
    - **Container:** ودجت متعدد الأغراض يسمح بتحديد الأبعاد، اللون، الديكورات، الحشو (Padding)، الهوامش (Margin) وغيرها. هو في الواقع مجموعة من الودجتات المتداخلة.    
    - **الأفضل للمساحة الفارغة:** `SizedBox` لأنه لا يقوم بالعديد من عمليات التحقق الإضافية التي يقوم بها `Container`.    
- **Pubspec.yaml:** ملف يحدد معلومات المشروع، التبعيات (Dependencies)، الأصول (Assets)، والخطوط (Fonts).   
- **التعامل مع مشاكل الـ Packages:**
    - إذا واجهت مشكلة في Package وتريد تعديلها، يمكنك عمل Fork للمستودع (Repository)، وتعديل الكود، ثم استخدام نسختك المعدلة عبر مسار `path` أو `git` في `pubspec.yaml`.     
    - هذا يسمح لك بتقديم مساهمات للمشروع الأصلي (Pull Request).   

## ميزات لغة Dart
- **`var` vs. `dynamic`:**
    - **`var`:** يتم تحديد نوع المتغير في وقت التجميع (Compile-time) بناءً على القيمة الأولية، ولا يمكن تغيير نوعه لاحقًا.   
    - **`dynamic`:** يمكن أن يحمل أي نوع من البيانات، ويمكن تغيير نوعه في وقت التشغيل (Run-time).   
- **`final` vs. `const`:**
    - **`const`:** قيمة ثابتة تمامًا في وقت التجميع، لا يمكن تغييرها أو جعل المتغير يشير إلى كائن آخر، والكائن نفسه غير قابل للتعديل (Immutable).    
    - **`final`:** يمكن تعيين قيمته مرة واحدة فقط، ولا يمكن للمتغير أن يشير إلى كائن آخر بعد تعيينه. ومع ذلك، إذا كان الكائن المشار إليه قابلاً للتعديل (Mutable)، فيمكن تغيير محتوياته.     

| الميزة     | `var`                                 | `dynamic`                                | `final`                                         | `const`                                     |
|:---------- |:------------------------------------ |:--------------------------------------- |:---------------------------------------------- |:------------------------------------------ |
| **نوع المتغير** | يُستنتج في وقت التجميع.              | يمكن أن يتغير في وقت التشغيل.            | يُعيّن مرة واحدة في وقت التشغيل.               | ثابت في وقت التجميع.                        |
| **إعادة التعيين** | مسموح (إذا لم يكن `final` أو `const`). | مسموح.                                   | غير مسموح بعد التعيين الأول.                    | غير مسموح.                                 |
| **قابلية التعديل** | يعتمد على النوع المستنتج.          | يمكن أن يكون قابلاً للتعديل.             | المتغير لا يمكن أن يشير لشيء آخر، لكن الكائن المشار إليه قد يكون قابلاً للتعديل. | المتغير والكائن المشار إليه غير قابلين للتعديل. |
      

- **Shared by Reference vs. Shared by Value:**
    - **Shared by Reference:** متغيرات متعددة تشير إلى نفس الكائن في الذاكرة. أي تغيير في الكائن عبر أي من المتغيرات سينعكس على الجميع. هذا هو السلوك الافتراضي في Dart للكائنات.     
    - **Shared by Value:** كل متغير يحصل على نسخة خاصة به من الكائن في الذاكرة. التغيير في نسخة لا يؤثر على الأخرى. (غير موجود بشكل مباشر في Dart، لكن يمكن محاكاته عبر `copyWith`).     
    - **`copyWith`:** دالة تسمح بإنشاء نسخة جديدة من الكائن مع إمكانية تعديل بعض قيمه، مما يوفر سلوكًا مشابهًا لـ "Shared by Value".    
    - **فائدتها:** يمكن استخدامها لعرض البيانات القديمة في حالة فشل طلب API، مع رسالة توضيحية للمستخدم.    

## البرمجة غير المتزامنة (Asynchronous Programming)
- **`Future` vs. `Stream`:**
    - **`Future`:** يمثل قيمة واحدة ستكون متاحة في المستقبل (مثل استجابة API). يتم إكمالها مرة واحدة فقط.    
    - **`Stream`:** يمثل تدفقًا مستمرًا من البيانات (Infinite List)، حيث يمكن تلقي قيم متعددة بمرور الوقت. مفيد في تطبيقات الوقت الفعلي (Real-time) مثل الدردشة.    
- **Event Loop و Isolates:**
    - **Isolates:** آليات في Dart تسمح بتشغيل أجزاء من الكود بشكل متوازٍ في ذاكرتها الخاصة، مما يمنع حظر الواجهة الرئيسية.   
    - **Event Loop:** في Dart، يعمل على Thread واحد (Single-threaded)، ويدير تنفيذ المهام.   
    - **آلية العمل:**
        - يتكون من **Microtask Queue** (ذات أولوية أعلى) و **Event Queue** (ذات أولوية أقل).    
        - المهام العادية (Synchronous) تعمل مباشرة على الـ Thread الرئيسي.   
        - عندما يكون الـ Thread الرئيسي فارغًا، يقوم الـ Event Loop بسحب المهام من الـ Microtask Queue أولاً، ثم من الـ Event Queue.    
        - يتم إرسال نتائج الـ Futures أو الأحداث من الـ Streams إلى الـ Event Queue ليتم معالجتها لاحقًا.    
    - **فائدته:** يضمن أن التطبيق يستجيب دائمًا، ويمنع تجمد الواجهة (UI Blocking).    

  
       

## بنية Flutter
- **Packages vs. Plugins:**
    - **Packages:** مكتبات Dart/Flutter لإعادة استخدام الكود.   
    - **Plugins:** Packages توفر وظائف خاصة بالمنصة (Platform-specific functionality) مثل الكاميرا أو GPS، وتتضمن كودًا أصليًا (Native code) لـ Android و iOS.   

## الشبكات والاتصال
- **Git vs. GitHub:**
    - **Git:** نظام تحكم في الإصدارات (Version Control System) محلي.   
    - **GitHub:** خدمة استضافة للمستودعات (Repositories) عن بعد، مبنية على Git.   
- **طرق التواصل مع الخادم (Backend):**
    - **REST (Representational State Transfer):** معيار شائع لبناء واجهات برمجة التطبيقات (APIs) يعتمد على HTTP.   
    - **GraphQL:** لغة استعلام (Query Language) لواجهات برمجة التطبيقات تسمح للعميل بطلب البيانات التي يحتاجها بالضبط.   
    - **WebSockets:** بروتوكول يوفر اتصالاً ثنائي الاتجاه ومستمرًا (Full-duplex persistent connection) بين العميل والخادم، مثالي لتطبيقات الوقت الفعلي.    
    - **gRPC:** إطار عمل (Framework) حديث للاتصال بين الخدمات، يعتمد على البروتوكول الثنائي (Binary protocol) ويوفر أداءً عاليًا.   

## الأمن
  
    
- **Authentication (المصادقة):** التحقق من هوية المستخدم ("من أنت؟")، مثل إدخال اسم المستخدم وكلمة المرور للحصول على Token.    
- **Authorization (الترخيص):** تحديد الصلاحيات الممنوحة للمستخدم بعد المصادقة ("ماذا يمكنك أن تفعل؟")، مثل هل المستخدم مسؤول (Admin) يمكنه حذف مستخدمين، أم مستخدم عادي بصلاحيات محدودة.    

## نصائح مهنية لمطور Flutter المبتدئ (Junior)
- **البحث عن الوظيفة الأولى:**
    - سوق Flutter تنافسي حاليًا، يتطلب العمل الجاد والتميز.    
    - يجب دراسة احتياجات السوق، وتطوير المهارات، وبناء مشاريع قوية ومبتكرة في الـ CV والـ GitHub.     
    - التركيز على جودة الكود، وعدم مجرد نسخ الأكواد من الكورسات.    
- **توقعات الراتب:**
    - تختلف الرواتب بشكل كبير حسب الشركة والموقع والخبرة.    
    - من المهم معرفة "قيمة" المطور في السوق للمساومة بفعالية. توجد أوراق عمل (Sheets) لمقارنة الرواتب.    
- **التوصيات (Recommendations) مقابل "الواسطة":**
    - التوصية هي شهادة من شخص عمل معك أو يعرف مستواك، مما يوفر وقت عملية التوظيف.    
    - تختلف عن "الواسطة" التي تعني إدخال شخص غير مؤهل، وهذا غير شائع في مجالات مثل البرمجة.    
- **تنوع عمليات المقابلة:**
    - تختلف إجراءات المقابلات من شركة لأخرى: قد تشمل مقابلات مع الموارد البشرية (HR)، أو مقابلات فنية (Technical)، أو اختبارات (Tasks) عملية.
